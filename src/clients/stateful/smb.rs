use crate::model::{Config, Target};
use async_trait::async_trait;
use tokio::net::TcpStream;
use tokio::process::Command;
use tokio::time::timeout;

use crate::clients::session::ClientSession;
use crate::clients::Client;

pub(crate) struct SmbClient;

// SMB Negotiate Protocol Request covering SMB1 and SMB2 dialects.
// Adapted from common version-scanning probes that include SMB 2.002 and SMB 2.??? dialect strings.
const SMB_NEGOTIATE_REQUEST: &[u8] = &[
    0x00, 0x00, 0x00, 0x85, 0xff, 0x53, 0x4d, 0x42, 0x72, 0x00, 0x00, 0x00, 0x00, 0x18, 0x01, 0x28,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x00, 0x02, 0x50, 0x43, 0x20, 0x4e, 0x45, 0x54,
    0x57, 0x4f, 0x52, 0x4b, 0x20, 0x50, 0x52, 0x4f, 0x47, 0x52, 0x41, 0x4d, 0x20, 0x31, 0x2e, 0x30,
    0x00, 0x02, 0x4c, 0x41, 0x4e, 0x4d, 0x41, 0x4e, 0x31, 0x2e, 0x30, 0x00, 0x02, 0x57, 0x69, 0x6e,
    0x64, 0x6f, 0x77, 0x73, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x57, 0x6f, 0x72, 0x6b, 0x67, 0x72, 0x6f,
    0x75, 0x70, 0x73, 0x20, 0x33, 0x2e, 0x31, 0x61, 0x00, 0x02, 0x4c, 0x4d, 0x31, 0x2e, 0x32, 0x58,
    0x30, 0x30, 0x32, 0x00, 0x02, 0x4e, 0x54, 0x20, 0x4c, 0x4d, 0x20, 0x30, 0x2e, 0x31, 0x32, 0x00,
    0x02, 0x53, 0x4d, 0x42, 0x20, 0x32, 0x2e, 0x30, 0x30, 0x32, 0x00, 0x02, 0x53, 0x4d, 0x42, 0x20,
    0x32, 0x2e, 0x3f, 0x3f, 0x3f, 0x00,
];

#[async_trait]
impl Client for SmbClient {
    fn name(&self) -> &'static str {
        "smb"
    }

    fn matches(&self, target: &Target) -> bool {
        matches!(target.resolved.port(), 139 | 445)
    }

    async fn execute(
        &self,
        stream: &mut TcpStream,
        cfg: &Config,
    ) -> anyhow::Result<crate::engine::reader::ReadResult> {
        let mut session = ClientSession::new(cfg);
        session.send(stream, SMB_NEGOTIATE_REQUEST).await?;
        session.read(stream, None).await?;

        if let Ok(peer) = stream.peer_addr() {
            if let Some(listing) = anonymous_list_users(&peer.ip().to_string(), cfg.read_timeout).await {
                session.append_metadata(listing);
            }
        }

        Ok(session.finish())
    }
}

async fn anonymous_list_users(host: &str, timeout_dur: std::time::Duration) -> Option<String> {
    let mut cmd = Command::new("smbclient");
    cmd.arg("-N")
        .arg("-L")
        .arg(format!("//{host}"));

    let output = timeout(timeout_dur, cmd.output()).await.ok()?.ok()?;

    if output.status.success() {
        let stdout = String::from_utf8_lossy(&output.stdout);
        if !stdout.is_empty() {
            return Some(format!("Anonymous smbclient listing:\n{stdout}"));
        }
    }

    None
}
